---
title: fasteR
author: Hyeongchan Bae
date: May 2022
output:
  pdf_document:
    toc: true
    latex_engine: xelatex
  html_document:
    toc: true
    toc_float: true
    theme: yeti
mainfont: NanumGothic
monofont: NanumGothic
fontsize: 12
linestretch: 1.5    
---

# Day 1

**R과 통계분석 (Tidyverse 활용) p.4~60**

## 1. Download

**R** 프로그래밍 언어. 제일 먼저 설치

* https://cran.r-project.org/bin/windows/base

**RStudio** R을 활용하기 위한 통합개발환경(IDE, Integrated Development Environment)

* 달리 말하면 RStudio 외에도 다양한 프로그램에서 R을 사용할 수 있음. 여러 언어를 사용하는 개발자는 VS Code 같은 단일 IDE를 활용하기도. 

* https://www.rstudio.com/products/rstudio/download

**Rtools** 패키지를 설치하다 보면 필요한 경우(Compile)가 더러 있음

* https://cran.r-project.org/bin/windows/Rtools

**Chrome Browser** Selenium 파트에서 사용할 예정

* https://www.google.com/intl/ko_kr/chrome

**Extra Files** 인턴의 깃허브 페이지. 강의 노트, 작성 코드 등 추가적인 파일을 업로드 해둠

* https://github.com/Rlearnchan/fasteR

## 2. Something to Know

### 1) "모두 다 같은 아마추어야"

* 익숙지 않고, 오래 걸리는 게 당연해요.

* 모든 과정을 R로 수행할 필요는 없으니, 잘 안 되면 데이터를 엑셀, STATA 등으로 옮겨 처리해오셔도 좋습니다.

### 2) R 파일(확장자)

**.R** 작성한 코드

* 좌상단 Script에서 코드 작성 $\to$ 필요한 부분 실행 $\to$ 좌하단 Console 창에서 실행 결과를 확인하는 게 일반적이라, 작업 첫 파트를 저장한 것이라 볼 수 있음.

* 코드를 적은 메모장쯤 되니, **비슷한 환경**이라면 타인에게 받은 코드를 실행하기만 해도 같은 결과를 시현함.

**.Rdata** 작업공간 이미지

* 우상단 Environment에 기록된, 작업하며 생성된 객체, 함수, 기타 데이터들의 총체.

* 임시로 만든, 코드 실행과 무관환 object 들도 저장. 

**.Rhistory** 작업 기록

* RStudio를 종료했다가, 다시 실행하면 이전 작업 상태가 비교적 온전히 남아있는데, 이를 위한 파일이라 하겠음.

**.Rmd** 마크다운 파일

* html, pdf, word 등을 만들기 위해 Markdown 문법으로 작성한, 코드 친구쯤 되는 녀석.

* 본 문서도 마크다운으로 작성. 소위 'R로 논문 쓴다' 할 때 등장.

### 3) 한글에 유독 취약한 R

**UTF-8** 인코딩 방식을 변경해주세요. 

* Tools $\to$ Global Options $\to$ Code $\to$ Saving 경로.

* 타인에게 받은, 혹은 건네준 코드 파일에서 한글이 깨져 보인다면 대체로 이 문제.

* File $\to$ Reopen with Encoding 기능을 활용해 대처하는 방법도 있음.

**Library Path** 패키지 설치 경로에 한글 네이밍이 없도록 해주세요.

```{r}

.libPaths() # 첫 번째가 default. 개인 폴더가 설정돼 두 개 나오기도 한다.

```

* (윈도우 기준 예시) 만일 [2] "C:/Users/**사용자 이름**/Documents/R/win-library/4.2.0" 경로에 한글이 포함된다면, 패키지를 다룰 때마다 오류 사인을 접할 공산이 큼.

* 새로 계정을 만들지 않는 이상, **사용자 이름** 구간 폴더 명은 변경하기도 어려움.

* 다음과 같이 **사용자 이름**이 없는 기본(공용) 라이브러리를 default로 설정하길 권장. 

```{r}

Sys.setenv('R_LIBS_USER' = 'C:/Program Files/R/R-4.2.0/library') 
# R의 '개인' 세팅을 앞서 발견한 '기본(공용)' 경로로 덮어쓰기.

.libPaths('R_LIBS_USER') # 바뀐 '개인 라이브러리'를 패키지 설치 경로로 설정.

```

```{r}

.libPaths() # 하나의 경로로 잘 세팅되고,

.libPaths() == Sys.getenv('R_LIBS_USER') # 개인 라이브러리 경로와도 일치

```

### 4) ?, ?? 사용법

**?** 모르는 함수 검색하기

```{r, eval = FALSE}

?print

```

* 대부분의 함수는 R Documentation 이라 해서 정의와 기능, 인자, 간단한 사용 예시 등을 요약해둔 페이지를 가지고 있음.

* 예컨대 `print()` 함수를 자세히 알고 싶다면, 위에서 처럼 `?` 하나 붙여서 실행하면 됨.

**??** 모르는 개념, 워딩 검색하기

```{r, eval = FALSE}

??print

```

* 하지만 함수 이름조차 모르거나, 기능을 연상할 키워드 정도만 간신히 아는 경우도 많음.

* `??`는 모든 R Documentation 에서 해당 단어가 포함된 것을 모두 골라 보여줌.

* 두 가지를 적절히 섞어 사용하는 게 좋음.

### 5) 구글링

* 사실 구글은 모든 걸 알고 있음.

* `str_dectect()` 식으로 함수 이름 자체를 검색하면 국내외 사용자들이 포스팅한 글을 찾아보기 편함.

* `warning` 혹은 `error` 사인은 해당 문구를 적당히 복사해 구글에 그대로 쳐보는 게 좋음.

* stackoverflow 같은 개발자 커뮤니티 게시물이 주로 나올 텐데, 같은 문제로 고민한 사람들이 꽤 많았기 때문.

## 3. Basic Function

### 1) 숫자 계산

```{r}

3+4-7/3 # 달리 명령어가 필요하진 않으나,

print(3+4-7/3) # print() 함수를 사용할 수도 있음

print(3+4-7/3, digits = 3) # 세 번째 자리에서 반올림

```

```{r}

rnorm(n = 5, mean = 0, sd = 1) # n(0, 1) 분포에서 5개 난수 생성

stats::rnorm(n = 5, mean = 0, sd = 1) # stats 패키지의 rnorm() 함수

```

* 기본 패키지, 혹은 `library()` 로 장착한 패키지의 함수는 `::` 표기를 사용하지 않아도 됨.

* 여러 패키지를 동시에 사용하는 경우, 유사한 이름의 함수 간 혼동을 피하기 위해 `::` 방식을 사용하기도 함.

```{r}

set.seed(seed = 10)

```

* reproducibility 위해서 난수 생성 규칙을 `set.seed()`로 부여.

```{r}

rnorm(5, 0, 1)

```

### 2) 텍스트

```{r}

'banana' # 작은 따옴표

"banana" # 큰 따옴표 모두 사용 가능

class('banana') # 문자 클래스

```

* `class()` 함수는 자주 쓰니 기억해 둘 필요가 있음.

```{r}

paste0('이제와', '뒤늦게', '무엇을 더 보태려하나') # 문자열 붙여서 하나로 만듦

paste0('이제와 ', '뒤늦게 ', '무엇을 더 보태려하나') # 띄어쓰기를 포함해서 붙이는 게 요령

paste('이제와', '뒤늦게', '무엇을 더 보태려하나') # 한 칸씩 띄어쓰는 게 default인 함수

paste('이제와', '뒤늦게', '무엇을 더 보태려하나', sep = '둠칫') # 사실 sep = ' ' 인자가 숨어있던 것. 바꿀 수도 있음.

```

### 3) 객체

```{r}

BR31 = 'Alien Mom' # 텍스트를 BR31 객체에 저장

br31 = 'Mint Choco' # 텍스트를 br31 객체에 저장

```

```{r}

BR31

br31

paste('Which do you prefer', BR31, 'or', br31) # 객체명을 입력하면 담긴 것을 가져다 씀.

```

* 객체 명을 지을 땐 **대소문자 구별**, 그리고 **첫 글자엔 숫자 및 기호 불가** 특성을 고려해야 함.

### 4) 벡터

```{r}

Yunha = c(4, 8, 6) # 숫자 세 개를 벡터로 묶어 저장

```

```{r}

Yunha

class(Yunha) # 숫자 속성이 그대로 남아 있음

```

```{r}

Yunha = c('Password', 4, 8, 6) # 원소가 하나라도 character가 섞이면

```

```{r}

Yunha # 따옴표 찍힌 것부터 느낌이 다르고,

class(Yunha) # 얄짤없이 전부 character로 저장

```

### 5) 행렬

```{r}

matrix(data = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12), nrow = 3, ncol = 4)

matrix(data = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12), nrow = 3, ncol = 4, dimnames = list(c('가', '나', '다'), c('A', 'B', 'C', 'D'))) # 행이름, 열이름 설정

matrix(data = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12),
       dimnames = list(c('가', '나', '다'), c('A', 'B', 'C', 'D')),
       nrow = 3, ncol = 4) # 코드가 슬슬 길어지니, 엔터를 적극 활용.

```

* 마지막 코드에선 인자들의 순서가 조금 다른데, 이는 인자명을 지정해줬기 때문에 가능한 것. 

* 지정만 잘 돼있으면 섞여도 상관 없음.

```{r}

mat <- matrix(1:12, 3, 4) # matrix() 함수의 처음 세 인자가 data, nrow, ncol 이므로 필요한 값만 입력.

colnames(mat) <- c('A', 'B', 'C', 'D') # 열이름 덮어쓰기

rownames(mat) <- c('가', '나', '다') # 행이름 덮어쓰기

```

* 하다 보면 쉬운 길을 찾아가게 됨.

* `1:12`는 `seq(from = 1, to = 12, by = 1)` 과 같음.

* `<-`는 `=`과 같음.

```{r}

mat

class(mat)

```

### 6) 데이터프레임

```{r}

윤하 <- as.data.frame(Yunha)

matthew <- as.data.frame(mat)

```

* `as.data.frame()` 함수는 벡터, 행렬 등을 인자로 받음.

```{r}

윤하

class(윤하)

```

* 데이터프레임은 row = observation, column = variable 개념이라, 열 이름을 웬만하면 채우려고 하는데, 여기선 character vector 이름인 Yunha를 차용한 모습.

* 벡터 이름 : 벡터 내용 = 변수 이름 : 관측치 느낌으로 해석한 듯.

```{r}

matthew

class(matthew)

```

### 7) 인덱싱

```{r}

Yunha[2] # Yunha 벡터의 두 번째 요소

mat[, 1] # mat 행렬의 첫 열

mat[2, 2] # mat 행렬의 (2, 2) 요소

```

```{r}

matthew$A # matthew 데이터프레임의 변수 A에 속한 값

matthew[2, 2] # matthew 데이터프레임의 (2, 2) 요소

```

* 데이터프레임의 인덱싱이 조금 더 깔끔한 느낌. 

* 실제 작업에도 용이한바, R의 데이터분석은 대개 데이터프레임 형태를 사용.

* 이를 `Pyhton`에서 구현하기 위해 `Pandas` 라이브러리를 만듦.

## 4. Others

**#** 주석처리

* 코드 설명 작성 : `print(a) # a를 출력한다`

* 해당 부분을 실행에서 제외 : `#print(a)` 

**업데이트** R, RStudio 모두 꾸준히 새 버전이 나오지만, 구 버전을 사용해도 큰 문제 없음

* R은 새로 설치하고 구 버전을 삭제하는 게 제일 간편. RStudio는 알아서 최신의 R을 인식해 사용.

* RStudio는 Help $\to$ Check for Updates 기능을 활용.

* 패키지는 Tools $\to$ Check for Package Updates

## 5. Quiz

**초급** 다음의 행렬을 만들어보자

```{r, echo = FALSE}

matrix(data = c(12, 17, 19, 21, 22, 25, 32, 34, 35),
       nrow = 3, ncol = 3,
       dimnames = list(paste0('Case #', 1:3), paste0('var', 1:3)))

```

**중급** `datasets::iris` 데이터를 가져와 다음을 해결해보자

1) `iris` 변수의 이름을 `names()` 함수로 확인하라.

2) `iris` 관찰값, 변수의 개수를 `dim()`, `nrow()`, `length()` 함수로 확인하라.

3) `iris` 처음 세 줄과 마지막 세 줄을 `head()`, `tail()` 함수로 출력하라.

**고급** 다음 코드의 문제점을 지적해보자. 수정본을 참고해도 좋다.

```{r, error = TRUE, message = FALSE}

I-DLE_MEMBERS <- c('소연', '미연', '민니', '우기', '슈화')

I-DLE_LYLICS <- c('Look at you 넌 못 감당해 날', 
                  'I got to drink up now 네가 싫다 해도 좋아', 
                  'Why are you cranky, boy? 뭘 그리 찡그려 너', 
                  '미친 연이라 말해 What's the loss to me ya', 
                  '사랑 그깟 거 따위 내 몸에 상처 하나도 어림없지', 
                  'Ye I'm a Tomboy (Umm ah umm)', 
                  'Ye I'll be the Tomboy (Umm ah)')
                  
TOMBOY <- data.frame(I-DLE_MEMBERS, I-DLE_LYLICS)

```

```{r}

IDLE_MEMBERS <- c('소연', '미연', '민니', '우기', '슈화')

IDLE_LYLICS <- c('Look at you 넌 못 감당해 날', 
                 'I got to drink up now 네가 싫다 해도 좋아', 
                 'Why are you cranky, boy? 뭘 그리 찡그려 너', 
                 "미친 연이라 말해 What's the loss to me ya", 
                 '사랑 그깟 거 따위 내 몸에 상처 하나도 어림없지', 
                 "Ye I'm a Tomboy (Umm ah umm)", 
                 "Ye I'll be the Tomboy (Umm ah)")
                  
TOMBOY <- data.frame(MEMBERS = IDLE_MEMBERS[c(3, 4, 1, 2, 4, 3, 5)], 
                     LYLICS = IDLE_LYLICS)

TOMBOY

```

# Day 2

**R과 통계분석 (Tidyverse 활용) p.102~146**

**파이썬 머신러닝 판다스 데이터 분석 p.2~55** 

## 1. What is Tidyverse

**Package for Packages** 데이터 분석을 위한 패키지의 모음집

```{r, eval = FALSE}

install.packages('tidyverse') # library() 와는 달리 따옴표를 붙여줘야 함, 이하에선 인스톨 생략

```

```{r, error = TRUE}

library(tidyverse) # tidyverse 패키지 장착

```

* ggplot2(시각화), dplyr(조작), stringr(텍스트), tibble(데이터프레임) 등의 패키지를 한 번에 로드, 장착할 수 있음.

* Conflicts 란에 제시되는 건 이미 라이브러리를 장착해 사용 중인 함수와 이름이 겹치는 케이스.

* 이제 `filter()` 함수는 `stats::filter()`가 아니라 `dplyr::mutate()`를 우선 선택.

* `stats::filter()` 식으로 풀네임을 써야 해당 함수 사용 가능.

**And then, and then** 직관적인 연결 작업

* tidyverse 계열 함수들은 첫 번째 입력값을 data로 통일. `function(data, actions)` 개념.

* pipe operator `%>%`는 앞선 작업 결과물을 다음 함수의 첫 요소로 대입하는 기능

* `x %>% f(y)` $\to$ `f(x, y)` 식으로 결합 사용하는 게 일반적.

## 2. Exercise : PSI 보도자료

**2022년 2월 PSI** https://www.kiet.re.kr/kiet_web/?sub_num=1503&state=view&idx=59127&ord=0

### 1) 데이터 로드

```{r, message = FALSE}

library(openxlsx) # openxlsx 패키지 장착

read.xlsx('PSI 연습용.xlsx')

```

```{r, message = FALSE}

PSI_ORIGINAL <- read.xlsx('PSI 연습용.xlsx') %>% 
  tibble() # 엑셀 파일을 읽어서 PSI_ORIGINAL 이라 명명. 

PSI_ORIGINAL # tibble을 사용하니, 직전보단 깔끔하게 저장된다. class 표시는 덤.

```

* `read.xlsx()` 함수의 첫 인자는 `xlsxFile` 으로, 해당 파일의 경로를 입력해야 함.

* 정확한 경로와 이름을 적으면서, 확장자 명을 꼭 포함할 것.

* 두 번째 인자는 `sheetName`, 미지정 시 첫 번째 시트를 로드한다. 다중 시트로 이뤄진 엑셀 파일이라면 시트 이름을 지정해주는 게 유용.

* 데이터 프레임을 가져올 땐 `tibble()` 함수를 거쳐서 단정하게 만들자.

* 여담으로 `xlsxFile`, `sheetName` 처럼 영문 가운데 capital을 섞어주는 걸 camel 표기법이라 함.

### 2) 훑어보기

```{r}

PSI_ORIGINAL %>% head() # 상위 순번 관측값만 표시, default = 6개 

PSI_ORIGINAL %>% names() # 변수 이름

PSI_ORIGINAL %>% dim() # dimension 

```

```{r}

PSI_ORIGINAL$구분 # 데이터 '구분' 열에 담긴 관측값들

PSI_ORIGINAL[2, ] # 데이터 2열 관측값

```

### 3) 응답자 비율 구하기

```{r}

PSI_ORIGINAL %>% # 원본 데이터에서
  select(구분, 응답수) %>% # 구분, 응답수 열을 고른 다음
  mutate(비율 = 응답수/235*100) # 새로운 열을 추가하는데, 얘는 응답수/235*100 계산값임.

```

* `select(data_table, columns, ... )` 원하는 column 고르기. 위치 인덱스나 변수 명을 적으면 됨.

* `select(-1)` 식으로 쓰면, 첫 번째 열을 제외하고 모두 선택.

* 변수 명에 띄어쓰기가 있다면, 해당 이름 전체를 따옴표나 accent 기호로 감싸야 함.

* `mutate(data_table, var_name = new_data, ...)` 새로운 열 만들기(덮어쓰기 가능).

```{r}

PSI_RATE.1 <- PSI_ORIGINAL %>%
  select(구분, 응답수) %>%
  mutate(비율 = 응답수/235*100) # 앞서 만든 데이터를 하나의 객체로 저장해두자.

PSI_RATE.2 <- PSI_RATE.1 %>% # 아까 하던 거에서
  mutate(비율 = round(비율, digits = 1)) %>% # 비율 값은 반올림해서 덮어씌우고
  slice(1:18) # 필요한 row만 선택하자.

PSI_RATE.2 # 좋긴 한데, 보도자료는 업종 순서가 달라서 붙여넣기가 애매.

```

* `slice(data_table, rows, ...)` 원하는 row 고르기. 

```{r}

PSI_RATE.2[c(2, 3, 4, 9, 8, 5, 7, 6, 11, 12, 10, 15, 14, 13, 16, 17, 18), ] # 순서를 바꾸면 되지

APPENDIX.1 <- PSI_RATE.2[c(2, 3, 4, 9, 8, 5, 7, 6, 11, 12, 10, 15, 14, 13, 17, 18), ] # 완성품 저장

```

* 완성품, 중간 작업물은 네이밍 규칙을 달리 가져가는 게 편하다.

* 객체를 왕창 만들다보면 헷갈릴 일이 생기기 마련.

### 4) 기상도 만들기

```{r}

PSI_WEATHER.1 <- PSI_ORIGINAL %>%
  select(3, '경기현황', `시장판매현황`, 수출현황,
         생산수준현황, 투자액현황, 채산성현황) # 인덱스, '변수명', `변수명`, 변수명 모두 가능

PSI_WEATHER.1
  
```

```{r}

PSI_WEATHER.2 <- PSI_WEATHER.1 %>%
  mutate_at(.vars = 2:7, .funs = round) # 2:7열 관측값에 반올림 적용

PSI_WEATHER.2

```

* `mutate_at(data_table, .vars, .funs, ...)` 는 `mutate()`의 고급 버전.

* `.funs`에 입력한 함수를 `.vars`에 입력한 변수에 일괄 적용하고 덮어씌움.

```{r}

PSI_WEATHER.3 <- PSI_WEATHER.2[c(1, 9, 8, 5, 7, 6, 11, 12, 10, 15, 14, 13, 16, 2, 3, 4), ]

colnames(PSI_WEATHER.3) <- c('구분', '업황', '내수', '수출', '생산수준', '투자액', '채산성')

PSI_WEATHER.3 # 갖다 붙이려 했는데, 숫자가 묘하게 다름

```

* R의 `round()` 함수는 `round(0.5) = 0` 으로 계산해버림.

* 그럼 어떻게 해야할까. 뭐 구글 가야죠.

```{r}

round2 = function(x, n = 0) {
  
  posneg = sign(x)
  z = abs(x)*10^n
  z = z + 0.5 + sqrt(.Machine$double.eps)
  z = trunc(z)
  z = z/10^n
  z*posneg
  
} # 구글 멋쟁이가 만들어둔 함수를 그대로 긁어오자

round(0.5) ; round2(0.5, 0) # 두 번째 인자 n은 digits

```

* `function(factors, ...) { what to do }` 식으로 사용자 함수를 정의할 수 있음.

* 아래 `mutate_at()` 함수에서 오류가 나서, n의 default 값만 `function(x, n = 0)` 으로 수정하자.

* tidyverse 함수에선 직전 작업 값 '.' 으로 표현한다. `.$구분` 으로 적어도 해당 흐름 내에선 '작업 중이던 데이터프레임의 구분 열' 쯤으로 인식하는 셈.

* `.vars`, `.funs`도 유사한 맥락의 네이밍인데, 설명하는 건 강의 레벨을 벗어나므로 스킵.

```{r}

PSI_WEATHER.2 <- PSI_WEATHER.1 %>%
  mutate_at(.vars = 2:7, .funs = round2) # 반올림 함수 교체

PSI_WEATHER.3 <- PSI_WEATHER.2[c(1, 9, 8, 5, 7, 6, 11, 12, 10, 15, 14, 13, 16, 2, 3, 4), ]

colnames(PSI_WEATHER.3) <- c('구분', '업황', '내수', '수출', '생산수준', '투자액', '채산성')

PSI_WEATHER.3

APPENDIX.2 <- PSI_WEATHER.3 # 완성품 저장

```

* `PSI_WEATER.2`, `PSI_WEATHER.3` 만드는 코드를 고치자.

* 객체 네이밍을 순차적으로 했어서, 수정할 부분을 빠르게 찾고, 해당 파트만 교체하는 게 어렵지 않다. 

### 5) 엑셀 출력하기

```{r, eval = FALSE}

write.xlsx(x = list(APPENDIX.1, APPENDIX.2), # 완성품 두 개를
           sheetName = c('응답자 비율', '기상도'), # 각각의 시트로 갖는
           file = 'PSI 보도자료.xlsx') # 엑셀 파일 생성

```

* 작업 중인 폴더에 엑셀 파일이 생성된다.

* list 클래스는 최상위 레벨로, 앞서 다룬 벡터, 행렬, 데이터프레임 등을 원소로 가질 수 있음.

* 가끔 list를 입력 인자로 요구하는 함수가 있으니 알아두자.

## 3. Advanced : 미국 수출데이터 가공

```{r, message = FALSE}

library(tidyverse)

USTRADE <- read_csv('미국수출 연습용.csv')

```

* UN Commodity Trade 자료의 일부.

```{r}

USTRADE # read_csv() 사용하면 tibble 형태로 저장

```

```{r}

USTRADE.1 <- USTRADE %>% 
  select(Year, `Trade Flow Code`, `Trade Flow`, `Reporter Code`,
         Reporter, `Partner Code`, Partner, `Partner ISO`, 
         `Commodity Code`, Commodity, `Qty Unit Code`, `Qty Unit`, 
         Qty, `Trade Value (US$)`) # 필요 변수 선택

USTRADE.1 %>% dim() # 변수 35개 -> 14개

```

* 띄어쓰기가 포함된 변수 명은 앞 뒤를 '' 내지 ``로 감싸야 함.

```{r, message = FALSE}

library(haven) # dta 로드 패키지

LINK <- read_dta('연계표 연습용.dta') %>% 
  select(hsc, ksic5) # 국제무역코드(hscode), 한국표준산업분류(ksic5)만 선택

```

* STATA를 사용하면 dta 파일로 작업물을 공유하는 경우가 있음.

* R에서는 해당 파일을 haven 패키지를 사용해 입출력.

* 비슷한 방식으로 타 프로그램 사용자와 co-work 가능.

```{r}

LINK

```

```{r}

LINK.1 <- LINK %>% 
  filter(!is.na(ksic5)) # 한국 분류로의 매칭이 목적이니, ksic5 공란 케이스는 제외
  
LINK.1 # number of rows가 6564 -> 6552로 축소

```

* `filter(data_table, condition, ...)` 함수는 조건에 맞는 observation만 선택.

* `is.na()` 함수는 결측치, 즉 `NA`인 경우 `TRUE`를 출력.

* `!` 연산자는 부정, not을 의미.

* 따라서 observation인데, ksic5 변수가 NA인 경우는 배제하고 LINK.1에 저장하겠다는 것.

```{r}

MANUFACTURE_KOREA <- seq(10, 34) # ksic5에서 제조업 파트는 10~34로 시작

temp1 <- rep(0, nrow(LINK.1)) # 영벡터

for (i in seq_along(MANUFACTURE_KOREA)) { # i = 1, 2, ..., 25에 대해 다음 작업 반복
  
  temp2 <- str_starts(string = as.character(LINK.1$ksic5), # ksic5가
                      pattern = as.character(MANUFACTURE_KOREA[i])) # 제조업 파트로 시작하면 TRUE
  
  temp1 <- temp1 + temp2 # 사칙연산에서 TRUE = 1이므로, 영벡터에 1 남기게 됨.
  
}

temp1 %>% head() # temp1은 제조업인 경우 1이 채워진 벡터

temp1 %>% sum() # 6413개 observation이 제조업에 해당

TESTER <- temp1 %>% as.logical() # 논리값으로 변경

TESTER %>% head() # 1은 다시 TRUE로 변환

```

* `seq_along(vector)` 함수는 1:length(vector) 수열을 출력.

* 논리값은 숫자로 변환하면 0, 1이므로 `sum()`과 궁합이 좋음.

```{r}

MANUFACTURE_WORLD <- LINK.1[TESTER, ]$hsc # 논리값을 인덱싱에 활용

MANUFACTURE_WORLD %>% head() # 한국 분류로 제조업에 해당하는 hscode

```

```{r, eval = FALSE}

USTRADE.2 <- USTRADE.1 %>% 
  filter(`Commodity Code` %in% MANUFACTURE_WORLD) %>% # 제조업 데이터만 선택
  arrange(Year, `Commodity Code`) %>% # 연도 순, HS code 순으로 정리
  relocate(Year, `Commodity Code`, 
           Commodity, `Trade Value (US$)`) # 주요 변수 앞으로 이동

write_csv(USTRADE.2, '미국수출 연계작업.csv') # 정리한 데이터셋을 csv로 저장

```

* `x %in% y`는 y vector 내에 x라는 인수가 있다면 TRUE를 반환.

* 변수, 객체 이름을 잘 지어야 헷갈리지 않음.

## 4. Quiz

**초급** `datasets::mtcars` 데이터를 가져와 다음을 해결해보자.

1) 차 이름을 새 변수로 설정해 표시하자. `rownames_to_column(var = 'car')` 함수를 사용하라.

2) 방금 만든 `car`, 그리고 `mpg`(miles per gallon), `cyl`(number of cylinders), `hp`(gross horsepower) 변수만을 선택하라.

3) 실린더 당 마력을 계산해 새 변수로 나타내라.

```{r}

# 1, 2, 3)

CAR.1 <- datasets::mtcars %>%
  rownames_to_column(var = 'car') %>%
  tibble() %>%
  select(car, mpg, cyl, hp) %>%
  mutate(hp_per_cyl = hp/cyl)

CAR.1

```

**중급** 다음 작업을 이어서 해보자.

1) 1974년 데이터인데, 이 때도 차는 벤츠가 짱이었나보다. 차 이름에 Merc 문자열을 포함한 관측값은 몇 개인가. `str_detect(pattern = 'Merc')` 함수를 사용하라.

2) 벤츠 차량 데이터만을 추려보자. `str_detect()` 의 결과값(논리값)을 인덱싱에 사용하라.

3) 벤츠 차량의 평균 마력은 얼마인가.

```{r}

# 1)

CAR.1$car %>%
  str_detect('Merc') %>%
  sum() # 논리값은 단순 덧셈하면 TRUE = 1, FALSE = 0 으로 계산된다.

# 2)

CAR.2 <- CAR.1[CAR.1$car %>% str_detect('Merc'), ]

CAR.2

# 3)

sum(CAR.2$hp) / 7

```

**고급** 다음 작업을 이어서 해보자.

1) 벤츠 차량의 수, 평균 마력을 구하라. `filter()`와 `summarise()` 함수를 사용하라.

```{r}

# 1)

CAR.3 <- CAR.1 %>%
  filter(str_detect(.$car, 'Merc')) %>%
  summarise(number = n(), hp_avg = (sum(hp)/n()))

CAR.3

```

# Day 3

## 1. What is API

**Computers' Talk** 컴퓨터나 컴퓨터 프로그램 사이의 연결

* language for computer 라서, 사람인 우리가 보고 쓰려면 일정 부분 배워야.

* 사람 보라고 만든 인터페이스는 UI(User Interface), 예컨대 삼성 갤럭시는 One UI 4.1

* API(Application Programming Interface)에 대한 짧은 클립을 추천.

* 노마드코더, API 기초개념 https://youtu.be/iyFHfzCRHA8

**Kosis Open API** 국가통계포털 공유서비스

* https://kosis.kr/openapi/introduce/introduce_01List.jsp

* 통계 데이터를 프로그램 상에서 바로 로드, 작업할 수 있음.

* 호출키(+인증키), 항목 설정 등으로 이뤄진 URL을 통해 데이터를 받아옴.

* 통계청뿐만 아니라 한은, 공공데이터포털, DART 등 대부분의 정보처는 API 서비스를 제공.

## 2. Exercise : 서비스업생산지수 업데이트

**서비스업 생산지수** http://kosis.kr/statHtml/statHtml.do?orgId=101&tblId=DT_1F01501&conn_path=I2

### 1) 데이터 이용 신청

**최초 사용자가, URL 생성 방식으로 진행함을 가정**

* 서비스이용 $\to$ 통계자료 탭을 눌러서 간단한 신청 폼을 작성.

* 자료등록 메뉴로 이동, 통계조사명 란에 '서비스업동향조사' 입력하고 검색.

* 서비스업동향조사 내 통계표가 여럿 나오는데, 2페이지의 산업별 서비스업생산지수의 사용여부 체크하고 자료등록.

### 2) 상세 조건 설정

* URL생성 메뉴로 이동, URL 생성 조건을 설정하자.

* 통계청 포털에서 체크박스 누르던 파트를 옮겨놓은 것.

* 필요한 데이터는 **불변/계절조정지수**의 최근값인데, **1레벨의 총지수**와 **3레벨 모든 항목**이 담겨있어야 함.

* 조회구분 = 시계열 선택

* 분류는 조금 길어서 다음을 순차적으로 진행

* 개별 옆의 선택 버튼 클릭

* 업종별 옆의 부등호를 등호로 교체

* 1을 3으로 교체하고 이동 버튼 클릭 (3레벨 분기로 전환)

* 체크박스 일괄 선택하고, 선택 버튼 눌러서 설정 저장

* 다시 개별 옆의 선택 버튼 클릭

* 총지수도 체크해 선택 버튼 클릭

* 항목의 불변지수, 계절조정지수 체크

* 활용 자료명에 '서비스업생산지수 업데이트' 입력

* URL생성 버튼 클릭

* 너무 많이 선택했다고 에러 사인. 3레벨 산업 분기를 전부 체크한 탓으로 보임.

* 원래는 대용량 데이터로 개별 신청해야 하나, 나름 대응 방안이 있음. 아래서 자세히 설명.

* 우선 불변지수 하나만 체크해서 URL 생성.

* 조금 기다리면 항목별(산업별)로 총 86개의 URL이 만들어짐.

### 3) 단일 데이터 로드

* 첫 번째 **불변지수x수도업**의 URL 보기를 클릭해보자.

* 해당 URL을 복사해 다음과 같이 로드.

```{r, eval = FALSE, message = FALSE}

library(tidyverse) # 데이터 핸들링
library(jsonlite) # JSON 파일 로드

URL <- 'https://kosis.kr/openapi/statisticsData.do?method=getList&apiKey=<인증키>=&format=json&jsonVD=Y&userStatsId=<아이디>/101/DT_1KS2015/2/1/<URL 고유번호>_1&prdSe=M&newEstPrdCnt=3'

SERVICE <- fromJSON(URL) %>% tibble()

SERVICE

```

```{r, echo = FALSE, message = FALSE}

library(tidyverse)
library(jsonlite)

URL <- 'https://kosis.kr/openapi/statisticsData.do?method=getList&apiKey=OTYwMWVjNTNmMmUxMjAyMGI5MjdkMjEwM2E4NTQ1OGQ=&format=json&jsonVD=Y&userStatsId=bhc5754/101/DT_1KS2015/2/1/20220503151131_1&prdSe=M&newEstPrdCnt=3'

SERVICE <- fromJSON(URL) %>% tibble()

SERVICE

```

* `fromJSON(source, ...)` 함수는 URL, 로컬 JSON파일 등을 읽어서 데이터 프레임으로 출력.  

* 최근 3개월 자료를 default로 설정해둔 바, 3개의 row가 로드됨.

* 16개의 column이 생성되었는데, 네이밍 요령은 **개발 가이드**란 이름으로 다음에서 제공.

* https://kosis.kr/openapi/devGuide/devGuide_0201List.jsp

* **통계표선택 방법**의 **출력결과** 항목을 보면 해당 column에 어떤 variable이 담겼는지 알 수 있음.

```{r}

temp <- SERVICE %>% 
  select(TBL_NM, # 통계표 이름
         PRD_DE, # 시점
         ITM_NM, # 지수(항목)
         C1_NM, # 산업(분류)
         C1, # 산업 코드
         DT) %>% # 지수값
  mutate(DT = as.double(DT)) # 값은 숫자 클래스로 변경
  
colnames(temp) <- c('통계', '시점', '지수', '산업', '코드', '값') # 직관적인 네이밍으로 변경

SERVICE.1 <- temp 

rm(temp) # 임시 객체 삭제

SERVICE.1 # 필요한 값만 정리

```

* 다루는 객체가 많아질수록 헷갈리기 마련. 임시 객체를 활용하는 것도 방법.

## 3. Advanced : 다중 데이터 로드

* 헌데, 이걸 86번 반복할 순 없는 노릇.

* 다시 URL생성 코너로 돌아가, **불변지수x하수, 폐수 및 분뇨 처리업** 의 URL을 확인하자.

* 자세히 보면 **$prdSe** 앞의 숫자가 **2**로 변경돼있다.

* 같은 조건에서 URL을 다중 생성하다보니, 다른 부분은 동일하더라도, 구별 차원에서 숫자를 달리 매겨놓은 것.

* 해당 숫자를 매개로 `for()` 구문을 사용하면 반복 작업을 할 수 있겠다.

* Day 2의 Advanced에 있던 내용과 유사하다. 아래 코드를 차용해도 좋지만, 가급적 대용량 통계자료 신청 기능을 이용하자.

```{r, eval = FALSE}

# 0. what do you need

KEY <- '개인 인증키'
ID <- 'Kosis ID'
INDEX.1 <- '불변지수 URL 고유번호'
INDEX.2 <- '계절조정지수 URL 고유번호'

# 1. setting

library(tidyverse) # 데이터 핸들링
library(jsonlite) # JSON 파일 로드
library(openxlsx) # 엑셀 입출력

# 2. url

BASE <- paste0('https://kosis.kr/openapi/statisticsData.do?method=getList', # 요청
               '&apiKey=', KEY, # 인증키
               '&format=json&jsonVD=Y', # 포맷 : JSON
               '&userStatsId=', ID) # 방식 : 사용자가 기등록한 자료 로드

CORE <- c(INDEX.1, INDEX.2) # 불변지수, 계절조정지수 URL 고유번호

NUMBER <- 1:86 # URL 개수

DATA <- tibble() # 데이터 담을 빈 그릇

# 3. data load

for (k in seq_along(CORE)) { # k = 1, 2에 대해서 다음 작업 실행
  
  temp1 <- tibble() # 데이터 담을 빈 그릇
  
  for (i in seq_along(NUMBER)) { # i = 1, 2, ... , 86에 대해서 다음 작업 실행
    
    URL <- paste0(BASE, # URL 앞 부분
                  '101/', # 통계청
                  'DT_1KS2015/', # 산업별 서비스업생산지수(2015=100)
                  '2/', # 시계열
                  '1/', # 간격 : 1
                  CORE[k], '_', NUMBER[i], # URL 나열
                  '&prdSe=', 'M', # 주기 : Month
                  '&newEstPrdCnt=', '1') # 최근 1개 자료
    
    temp2 <- tryCatch(fromJSON(URL) %>% # fromJSON ~ select 함수를 실행하되,
                      tibble() %>% 
                      mutate(번호 = i) %>% 
                      select(번호, PRD_DE, ITM_NM, C1_NM, C1, DT),
                      error = function(e) tibble(NULL)) # 오류(데이터 부재) 발생하면 스킵
    
    temp1 <- rbind(temp2, temp1) # stacking
    
  }
  
  temp3 <- temp1 %>% 
    arrange(nchar(C1), C1) %>% # 분류값 순으로 정렬  
    mutate_at(vars(DT), as.double) # 수치값 class 숫자로 변경
  
  DATA <- rbind(temp3, DATA) # stacking
  
}

# 4. finish

rm(list = c('temp1', 'temp2', 'temp3')) # 임시 객체 삭제

colnames(DATA)[2:6] <- c('시점', '지수', '산업', '코드', '값') # 변수명 변경

# 5. export

write.xlsx(DATA, '서비스업생산지수 업데이트.xlsx') # 엑셀 파일로 저장

```

* `0. what do you need` 파트를 본인 경우에 맞게 수정하자.

* 이걸 덥석 이해했다면, 당신은 본 강의 레벨을 아득히 넘는다.

```{r}

read.xlsx('서비스업생산지수 업데이트.xlsx') %>% 
  tibble() %>% 
  select(-1) # 첫 번째 열은 삭제

```

* 번호는 오류 체크용(오류나면 해당 번호 부재)으로 만들었던지라, 최종 결과물에 굳이 담을 필요는 없음.

# Day 4

## 1. What is Selenium



## 2. Exercise : 업무포털 로그인

```{r, eval = FALSE}

library(tidyverse) # 데이터 핸들링
library(rstudioapi) # 터미널 사용
library(RSelenium) # 크롬 자동화
library(rvest) # html 해석

ID <- '포털 아이디'
PW <- '포털 비밀번호'

TERM_COMMAND <- 'java -Dwebdriver.gecko.driver="geckodriver.exe" -jar selenium-server-standalone-4.0.0-alpha-1.jar -port 4445' # 원격으로 두 파일 실행하라는 커맨드
terminalExecute(command = TERM_COMMAND) # RStudio Terminal 탭 열어서 상기 커맨드 입력
REMDR = remoteDriver(port = 4445, browserName = 'chrome') # 브라우저로 크롬 선택

REMDR$open() # 크롬 오픈

REMDR$navigate('https://ep.kiet.re.kr/index.do') # 업무 포털 접속해서
    
BUTTON_LOGIN <- REMDR$findElement('xpath', '//*[@id="f_login"]/ul/li[3]') # 로그인 버튼
TEXT_ID <- REMDR$findElement('xpath', '//*[@id="loginId"]') # 아이디 입력창
TEXT_PW <- REMDR$findElement('xpath', '//*[@id="pwd"]') # 패스워드 입력창을 찾아내고
    
TEXT_ID$sendKeysToElement(list(ID)) # 아이디 입력
TEXT_PW$sendKeysToElement(list(PW)) # 패스워드 입력
BUTTON_LOGIN$clickElement() # 로그인 버튼 클릭

```

## 3. Advanced : 아이유 Top 100 수록곡


